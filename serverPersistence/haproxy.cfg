global
	log 127.0.0.1 local0
	log 127.0.0.1 local1 notice
	maxconn 4096
	description Our awesome HAProxy Stats page # that is going with show-legends

defaults
	mode http
	log global
	option dontlognull
	timeout connect 5s
	timeout client 60s
	timeout server 60s
	errorfile 400 /usr/local/etc/haproxy/errors/400.http
	errorfile 403 /usr/local/etc/haproxy/errors/403.http
	errorfile 408 /usr/local/etc/haproxy/errors/408.http
	errorfile 500 /usr/local/etc/haproxy/errors/500.http
	errorfile 502 /usr/local/etc/haproxy/errors/502.http
	errorfile 503 /usr/local/etc/haproxy/errors/503.http
	errorfile 504 /usr/local/etc/haproxy/errors/504.http

listen  stats
    	bind *:1936
    	mode http
    	stats enable
    	stats refresh 30s # refresh the page
    	stats auth admin:password # set the auth(if not, no auth)
    	stats hide-version
    	stats realm Haproxy\ Statistics
    	stats uri /
	stats show-desc # this allow to show the description in the global directives
	stats show-legends # for the UI to show the legends
	stats admin if TRUE # allow the servers' administration from the UI
    	# bind *:9000 ssl crt /etc/ssl/certs/mycert.pem # with ssl


# ====== ignoring persistence for some files ========
# allow to serve static files from any server(without caring about session)
frontend myfrontend
	bind *:80
  	default_backend mybackend

backend mybackend
 	cookie SERVER_USED insert indirect nocache
   	server web1 web1:80 check cookie web1
   	server web2 web2:80 check cookie web2
	ignore-persist if { path_end .css .js .html .png .jpeg }



# ====== forcing persistence on a down server  ========
# frontend myfrontend
# 	bind *:80
#   	default_backend mybackend
# 
# backend mybackend
# 	# option httpchk # this line does not work
# 	option redispatch
# 	balance roundrobin
#  	cookie SERVER_USED insert indirect nocache
#    	server web1 web1:80 check cookie web1
#    	server web2 web2:80 check cookie web2
# 	use-server web1 if { url_param(serv) eq 1 }
# 	use-server web2 if { url_param(serv) eq 2 }
# 	force-persist if { url_param(offline) eq true }

# # ======== redispactching to another server ===========
# frontend myfrontend
# 	mode tcp
# 	bind *:80
#   	default_backend mybackend
# 
# backend mybackend
# 	mode tcp
#   	server web1 web1:80 check 
#   	server web2 web2:80 check
# 	stick match src table mystorage
# 	stick store-request src table mystorage
# 	option redispatch # !important:help to redirect faster req to new other srv if sticky crashed 
# 
# backend mystorage
# 	stick-table type ip size 1m expire 30m


# # ====== use stick table ======= 
# # in this case the request are identified on the tcp layer(if layer 7 better using cookie)
# frontend myfrontend
# 	mode tcp
# 	bind *:80
#   	default_backend mybackend
# 
# backend mybackend
# 	mode tcp
#   	server web1 web1:80 check 
#   	server web2 web2:80 check
# 	stick match src table mystorage
# 	stick store-request src table mystorage
# 
# backend mystorage
# 	stick-table type ip size 1m expire 30m


# frontend myfrontend
# 	mode tcp
# 	bind *:80
#   	default_backend mybackend
# 
# backend mybackend
# 	mode tcp
# 	stick-table type ip size 1m expire 30m
#   	server web1 web1:80 check 
#   	server web2 web2:80 check
# 	stick match src
# 	stick store-request src


# # ====== use a cookie session ========
#frontend myfrontend
#	bind *:80
#  	default_backend mybackend

# backend mybackend
# 	cookie SERVER_USED insert indirect nocache
#   	server web1 web1:80 check cookie web1
#   	server web2 web2:80 check cookie web2




